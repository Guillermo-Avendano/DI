<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <!--xsl:strip-space elements="description" /-->

  <xsl:output method="xml" />

  <xsl:template match="/">
    <!--xsl:comment>***********************************</xsl:comment-->
    <!--xsl:comment>xsl:template match="/"</xsl:comment-->
    <xsl_stylesheet version="1.0"
		aaaahttpxmlnsxsl="aaaahttp://www.w3.org/1999/XSL/Transform"
		xmlns:exslt="http://exslt.org/common"
		xmlns:msxsl="urn:schemas-microsoft-com:xslt"
		exclude-result-prefixes="exslt msxsl"
    	>
    	
    	<!-- EDI-8651 [MIA/InfoRetrieval] changing the setting 'mode' (only effective when InfoRetrieval is not connected) in applicationsSolr_rir.properties has no effect
    	This parameter will be extracted
    	(either from the HTTP request parameter '_Mode'
    	or from the configuration setting 'mode' in applicationSolr_rir.properties)
    	and be provided on-the-fly by Java to the XSL transformer instance executing this stylesheet -->
		<xsl:element name="xsl:param" xmlns="xsl">
			<xsl:attribute name="name">
				<xsl:text>requestedSearchPatternMode</xsl:text>
			</xsl:attribute>
		</xsl:element>
		
      <xsl_template match="/">
         <xsl_apply-templates select="RocService"/>
      </xsl_template>

      <xsl_template match="patterns"/>
      <xsl_template match="option"/>
      <xsl_template match="valDom"/>


      <xsl:apply-templates select="//pattern"></xsl:apply-templates>
      <xsl:apply-templates select="//rule" mode="b"></xsl:apply-templates>
      <xsl:apply-templates select="//rule" mode="doNothing"></xsl:apply-templates>

      <xsl_template match="node()|@*" >
        <xsl_copy>
          <xsl_apply-templates select="node()|@*" />
        </xsl_copy>
      </xsl_template>
      
      <!-- Inject into result XSLT a polyfill for the 'tokenize' function since we are using XSLT 1.0 -->
		<xsl:text disable-output-escaping="yes">
<!--
			<xsl:call-template name="string-replace-all">
				<xsl:with-param name="text">
-->
					<![CDATA[
					<xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" name="tokenize">
						<xsl:param name="text" select="."/>
						<xsl:param name="separator" select="','"/>
						<xsl:choose>
							<xsl:when test="not(contains($text, $separator))">
								<item>
									<xsl:value-of select="normalize-space($text)"/>
								</item>
							</xsl:when>
							<xsl:otherwise>
								<item>
									<xsl:value-of select="normalize-space(substring-before($text, $separator))"/>
								</item>
								<xsl:call-template name="tokenize">
									<xsl:with-param name="text" select="substring-after($text, $separator)"/>
								</xsl:call-template>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:template>
					]]>
<!--
				</xsl:with-param>
				<xsl:with-param name="replace" select="'xsl:'" />
				<xsl:with-param name="by" select="'xsl_'" />
				<xsl:with-param name="disableOutputEscaping" select="'yes'" />
			</xsl:call-template>
-->
		</xsl:text>
    </xsl_stylesheet>
  </xsl:template>

  <!--
   ******** template match="pattern" **********************************
 
    example: this is generated by the following template:
  - <xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" match="node()[@patternRef='p1']">
    - <xsl:copy xmlns="xsl">
      <xsl:apply-templates select="node()|@*" /> 
  -->
  <xsl:template match="pattern">

   <!--xsl:comment>start: xsl:template match="pattern"</xsl:comment-->
   <xsl:element name="xsl:template" xmlns="xsl">
    <xsl:attribute name="match">node()[@patternRef='<xsl:value-of select="@id" />']</xsl:attribute>
     
     <xsl_copy>
       <xsl_apply-templates select="node()|@*" />
       <xsl:apply-templates select="child::*" mode="g"/>
     </xsl_copy>
      
    </xsl:element>
  </xsl:template>


  <!--
   ******** template match="rule" mode="g" **********************************
 
    example: this is generated by the following template:
   <xsl:apply-templates mode="g" select="searchName" /> 

  -->
  <xsl:template match="rule" mode="g">

    <!--xsl:comment>start: xsl:template match="rule" mode="g"</xsl:comment-->
    <xsl:element name="xsl:apply-templates">
      <xsl:attribute name="select">
        <xsl:value-of select="@forall" />
      </xsl:attribute>
      <xsl:attribute name="mode">g</xsl:attribute>
    </xsl:element>
  </xsl:template>

  
  <!-- 
  ******** template match="param" ********************************************
  
  example: this is generated by the following template:
  - <xsl:variable name="COLUMN"><xsl:value-of select="@col" /> </xsl:variable>
  - <xsl:choose>
      <xsl:when test="contains($COLUMN,'$')" /> 
    - <xsl:otherwise><LA xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    -->
    <xsl:template match="param">
    <!--xsl:comment>start: xsl:template match="param"</xsl:comment-->
    <xsl:apply-templates select="param"/>
    <xsl:variable name="hasDuplicate">
      <xsl:for-each select="ancestor::param">
        <xsl:value-of select="@name"/>,
      </xsl:for-each>
      <xsl:for-each select="ancestor::param/preceding-sibling::param">
        ,<xsl:value-of select="@name"/>,
      </xsl:for-each>
      <xsl:for-each select="ancestor::param/preceding-sibling::param/descendant::param">
        ,<xsl:value-of select="@name"/>,
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="myParam">{$<xsl:value-of select="@name"/>}</xsl:variable>
    <!--xsl:comment><xsl:value-of select="$xxx"/></xsl:comment-->
     <!--cannot handle the following case: specail case: name="value" value="//valDom[@id='{$vd}']/value[@name='{$value}']/@val" value <TA text="(TA {$valuemore} ~/ @*{$str}@*) " />--> 
      <xsl:choose>
        <xsl:when test="contains(parent::*/child::*/@text,$myParam) or contains(parent::param/@value,$myParam)">       
          <xsl:choose>
            <xsl:when test="contains($hasDuplicate,@name)"></xsl:when>
            <xsl:otherwise>
              <xsl:element name="xsl:variable">
                <xsl:attribute name="name">
                  <xsl:value-of select="@name"/>
                </xsl:attribute>
                <!--xsl:apply-templates select="node()" /-->
                <xsl:element name="xsl:value-of">
                  <xsl:attribute name="select">
                    <xsl:value-of select="@value" />
                  </xsl:attribute>
                </xsl:element>
              </xsl:element>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise></xsl:otherwise>
      </xsl:choose>
    
		<xsl:if test="position()=1">
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">
					<xsl:text>mode</xsl:text>
				</xsl:attribute>
				<xsl:text disable-output-escaping="yes">
				<![CDATA[
					<xsl:choose>
						<xsl:when test="@mode">
							<xsl:value-of select="@mode" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$requestedSearchPatternMode" />
						</xsl:otherwise>
					</xsl:choose>
				]]>
				</xsl:text>
			</xsl:element>
		</xsl:if>
  </xsl:template>

  <!-- 
  ******** template match="rule" mode="doNothing" ********************************************
  
  example: this is generated by the following template:
    <xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" match="test1" /> 

    -->
  <xsl:template match="rule" mode="doNothing">
    <!--xsl:comment>start: xsl:template match="rule" mode="doNothing"</xsl:comment-->
    <xsl:element name="xsl:template">
      <xsl:attribute name="match">
        <xsl:value-of select="@forall" />
      </xsl:attribute>
    </xsl:element>
  </xsl:template>


  <!-- 
  ******** template match="rule" mode="b" ********************************************
  
  example: this is generated by the following template:
  <xsl:template xmlns:xsl="http://www.w3.org/1999/XSL/Transform" match="searchNameV2" mode="g">
       <xsl:variable name="str"><xsl:value-of select="@param" /></xsl:variable>
       ...
       <XNAME xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
       ..
  </xsl:template>

  -->
  <xsl:template match="rule" mode="b">
    <!--xsl:comment>start: xsl:template match="rule" mode="b"</xsl:comment-->
    <xsl:element name="xsl:template">
      <xsl:attribute name="match">
        <xsl:value-of select="@forall" />
      </xsl:attribute>
      <xsl:attribute name="mode">g</xsl:attribute>

      <xsl:apply-templates select="param">
        <xsl:with-param name="parent_pos"><xsl:value-of select="position()"/></xsl:with-param>
      </xsl:apply-templates>
      <!--xsl:apply-templates select="node()[name()!='param']" mode="SDCACElem"/-->
      <!--Test if a external value is given, when not ignore the expression
          ToDo: mandatory external variables
      -->
      
  
      <xsl_choose>
        <xsl:for-each select="param">
          <xsl:variable name="myParam">{$<xsl:value-of select="@name"/>}</xsl:variable>
          <xsl:comment>
            <xsl:value-of select="parent::*/child::*/@text"/> | <xsl:value-of select="parent::param/@value"/> | '<xsl:value-of select="$myParam"/>'
          </xsl:comment>
          
          
          
          <xsl:choose>
             <xsl:when test="contains(parent::*/child::*/@text,$myParam) or contains(parent::param/@value,$myParam)">
               
               <xsl_when>
                 <xsl:attribute name="test">(contains($<xsl:value-of select="@name"/>,'{$') and not(contains($<xsl:value-of select="@name"/>, 'NOW}')))
                 or (not(string('<xsl:value-of select="@allowEmpty"/>')=string(true())) and $<xsl:value-of select="@name"/>='')</xsl:attribute>
               </xsl_when>
               
             </xsl:when>
          </xsl:choose>
          </xsl:for-each>
        <xsl_when test="@name='fubaquatscher'">
        </xsl_when>
        <xsl_otherwise>
          <xsl:apply-templates select="node()[name()!='param']" mode="SDCACElem"/>
        </xsl_otherwise>
      </xsl_choose>
    </xsl:element>
  </xsl:template>

  <xsl:template match="@text">
    <!--xsl:comment>***********************************</xsl:comment-->
    <!--xsl:comment>start: xsl:template match="@text"</xsl:comment-->

    <xsl:variable name="test" select="parent::*/@text"></xsl:variable>
    <xsl:element name="xsl:attribute">
      <xsl:attribute name="name">text</xsl:attribute>
      <xsl:value-of select="parent::*/@text"/>
    </xsl:element>
    <!--xsl:copy-of select="parent::*/parent::*/param" /-->
    <!--xsl:comment>xsl:apply-templates select="parent::*/parent::*/param"  mode="copyAttributes"</xsl:comment-->
    <xsl:apply-templates select="parent::*/parent::*/param" mode="copyAttributes">
      <xsl:with-param name="text" select="parent::*/@text"></xsl:with-param>
    </xsl:apply-templates>
  </xsl:template>

	<xsl:template match="@multiValued">
		<!-- Does nothing, we do not want to copy that attribute of a param -->
	</xsl:template>
  
  <!-- Invoked, as internal process of a for-each instruction, on a SDCACElem that contains a reference to a multiValued param -->
  <xsl:template match="node()" mode="multiValuedSDCACElem">
  	<xsl:param name="SDCACElem" select="."/>
  	<xsl:param name="multiValuedParam"/>
		<xsl:copy>
			<xsl:element name="xsl:attribute">
				<xsl:attribute name="name">text</xsl:attribute>
				<!-- not working with XSLT 1.0 
				<xsl:value-of select="replace(@text, concat('{$', $multiValuedParam/@name, '}'), 'current()')" />
				-->
				<xsl:call-template name="string-replace-all">
					<xsl:with-param name="text" select="$SDCACElem/@text" />
					<xsl:with-param name="replace" select="concat('{$', $multiValuedParam/@name, '}')" />
					<xsl:with-param name="by" select="'&lt;xsl:value-of select=&quot;.&quot;/&gt;'" />
					<xsl:with-param name="disableOutputEscaping" select="'yes'" />
				</xsl:call-template>
			</xsl:element>
			<!-- only for tracking purpose: recreate the param element -->
			<xsl:element name="param">
				<xsl:attribute name="name"><xsl:value-of select="$multiValuedParam/@name" /></xsl:attribute>
				<xsl:attribute name="value"><xsl:value-of select="$multiValuedParam/@value" /></xsl:attribute>
			</xsl:element>
		</xsl:copy>
  </xsl:template>
  
  <xsl:template match="node()" mode="SDCACElem">
    <!--xsl:comment>***********************************</xsl:comment-->
    <!--xsl:comment>start: xsl:template match="node()|@*" mode="SDCACElem"</xsl:comment-->
    <xsl:variable name="multiValuedParam" select="preceding-sibling::param[@multiValued='true']" />
	<xsl:choose>
		<xsl:when test="count($multiValuedParam)>0">
			<xsl:element name="xsl:variable">
				<xsl:attribute name="name">values</xsl:attribute>
				<!-- not working with XSLT 1.0 
					<xsl:attribute name="select">tokenize(normalize-space($<xsl:value-of select="$multiValuedParam/@name"/>), ',')</xsl:attribute>
				-->
				<xsl:element name="xsl:call-template">
					<xsl:attribute name="name">tokenize</xsl:attribute>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">text</xsl:attribute>
						<xsl:attribute name="select">normalize-space($<xsl:value-of select="$multiValuedParam/@name"/>)</xsl:attribute>
					</xsl:element>
					<xsl:element name="xsl:with-param">
						<xsl:attribute name="name">separator</xsl:attribute>
						<xsl:attribute name="select">','</xsl:attribute>
					</xsl:element>
				</xsl:element>
			</xsl:element>
						
			<xsl:element name="xsl:choose">
				<xsl:element name="xsl:when">
					<xsl:attribute name="test">function-available('msxsl:node-set')</xsl:attribute>
					<xsl:element name="xsl:for-each">
						<xsl:attribute name="select">msxsl:node-set($values)/node()</xsl:attribute>
						<xsl:apply-templates select="." mode="multiValuedSDCACElem">
							<xsl:with-param name="multiValuedParam" select="$multiValuedParam" />
						</xsl:apply-templates>
					</xsl:element>
				</xsl:element>
				<xsl:element name="xsl:otherwise">
					<xsl:element name="xsl:for-each">
						<xsl:attribute name="select">exslt:node-set($values)/node()</xsl:attribute>
						<xsl:apply-templates select="." mode="multiValuedSDCACElem">
							<xsl:with-param name="multiValuedParam" select="$multiValuedParam" />
						</xsl:apply-templates>
					</xsl:element>
				</xsl:element>
			</xsl:element>
			
		</xsl:when>
		<xsl:otherwise>
			<xsl:copy>
				<xsl:apply-templates select="node()|@*"/>
			</xsl:copy>
		</xsl:otherwise>
	</xsl:choose>
  </xsl:template>

	<!-- CAUTION: define a more specific rule for text node otherwise we have issue with multi-valued params because the same XSL variabe is re-defined multiple times! -->
	<xsl:template match="text()|@*" mode="SDCACElem">
		<!--xsl:comment>***********************************</xsl:comment-->
		<!--xsl:comment>start: xsl:template match="node()|@*" mode="SDCACElem"</xsl:comment-->
		<xsl:copy>
			<xsl:apply-templates select="node()|@*"/>
		</xsl:copy>
	</xsl:template>
	
  	<xsl:template match="comment()" mode="SDCACElem">
		<!-- Does nothing -->
	</xsl:template>
	
  <xsl:template match="node()|@*">
    <!--xsl:comment>***********************************</xsl:comment-->
    <!--xsl:comment>start: xsl:template match="node()|@*"</xsl:comment-->

    <xsl:copy>
      <xsl:apply-templates select="node()|@*" />
    </xsl:copy>
  </xsl:template>

  <xsl:template match="@*">
    <!--xsl:comment>***********************************</xsl:comment-->
    <!--xsl:comment>start: xsl:template match="@*"</xsl:comment-->

    <xsl:copy/>
     
  </xsl:template>

  <xsl:template match="node()|@*" mode="g">
    <!--xsl:comment>***********************************</xsl:comment-->
    <!--xsl:comment>start: xsl:template match="node()|@*" mode="g"</xsl:comment-->

    <xsl:copy>
      <xsl:apply-templates select="node()|@*" mode="g"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="param" mode="copyAttributes">
    <xsl:param name="text"></xsl:param>

    <!--xsl:comment>***********************************</xsl:comment-->
    <!--xsl:comment>start: xsl:template match="node()|@*" mode="copyAttributes"</xsl:comment-->

      <xsl:variable name="myParam">{$<xsl:value-of select="@name"/>}</xsl:variable>
      <xsl:choose>
        <xsl:when test="contains($text,$myParam)">

          <xsl:copy>
          <xsl:copy-of select="@*"/>
          
        </xsl:copy>
      </xsl:when>
    </xsl:choose>
    
    <!--xsl:copy>
      <xsl:apply-templates select="@*" mode="copyAttributes"/>
    </xsl:copy-->

    <!-- //valDom[@id=$vd]/value[@name=$value]/param[@name='Date1']/@rule" Todo: nächste Werte daraus berechnen-->

    <!--
    <xsl:if test="contains(@value,'//valDom')">   
      <xsl_comment>
        <xsl_value-of select="$vd"/>
      </xsl_comment>
      <xsl_for-each select="//valDom[@id=$vd]">
        <xsl_apply-templates select="node()|@*"/>
      </xsl_for-each>
    </xsl:if>-->
    
  </xsl:template>
  
	<xsl:template name="string-replace-all">
		<xsl:param name="text" />
		<xsl:param name="replace" />
		<xsl:param name="by" />
		<xsl:param name="disableOutputEscaping" select="'no'" />
		<xsl:choose>
			<xsl:when test="contains($text, $replace)">
				<xsl:choose>
					<xsl:when test="$disableOutputEscaping='yes'">
						<xsl:value-of select="substring-before($text,$replace)" disable-output-escaping="yes" />
						<xsl:value-of select="$by" disable-output-escaping="yes" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="substring-before($text,$replace)" />
						<xsl:value-of select="$by" />
					</xsl:otherwise>
				</xsl:choose>
				<xsl:call-template name="string-replace-all">
					<xsl:with-param name="text" select="substring-after($text,$replace)" />
					<xsl:with-param name="replace" select="$replace" />
					<xsl:with-param name="by" select="$by" />
					<xsl:with-param name="disableOutputEscaping" select="$disableOutputEscaping" />
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$disableOutputEscaping='yes'">
						<xsl:value-of select="$text" disable-output-escaping="yes"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$text" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="tokenize">
		<xsl:param name="text" select="."/>
		<xsl:param name="separator" select="','"/>
		<xsl:choose>
			<xsl:when test="not(contains($text, $separator))">
				<item>
					<xsl:value-of select="normalize-space($text)"/>
				</item>
			</xsl:when>
			<xsl:otherwise>
				<item>
					<xsl:value-of select="normalize-space(substring-before($text, $separator))"/>
				</item>
				<xsl:call-template name="tokenize">
					<xsl:with-param name="text" select="substring-after($text, $separator)"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
</xsl:stylesheet>